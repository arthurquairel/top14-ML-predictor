# -*- coding: utf-8 -*-
"""Top14_predictions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hlNKuU1Zuslwe7Jrdj8T3i02cHp1jw6x
"""

# math, numpy and plot
import numpy as np
import math
import matplotlib
import matplotlib.pyplot as plt
# torch
import torch
import torch.autograd as autograd
import torch.nn.functional as F
import torch.nn as nn
from torch.utils.data import TensorDataset, DataLoader

# gzip
import gzip
import pickle
import pandas as pd
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import RobustScaler
from sklearn.preprocessing import QuantileTransformer

import pandas as pd

# 1. Chargement du fichier (header=1 car la 1Ã¨re ligne est vide)
data = pd.read_csv('Predictions top 14 - Feuille 1 (1).csv', header=1)

# 2. Nettoyage des colonnes numÃ©riques (gestion virgules et espaces)
cols_a_nettoyer = ['Possesion', 'Occupation', 'Transf_att', 'metre_att', 'plaquage_def']

def nettoyer_chiffre(valeur):
    if isinstance(valeur, str):
        valeur = valeur.replace(' ', '').replace(',', '.')
    return float(valeur)

for col in cols_a_nettoyer:
    if col in data.columns:
        data[col] = data[col].astype(str).apply(nettoyer_chiffre)

# 3. Calcul des statistiques de performance
# Taux de victoire = (Victoires / Matchs) * 100
data['Win Rate (%)'] = (data['win'] / data['Matchs']) * 100

# Points Classement EstimÃ©s = (Victoire * 4) + (Nul * 2)
# (Attention : ne prend pas en compte les bonus offensifs/dÃ©fensifs)
data['Pts Classement (Est)'] = (data['win'] * 4) + (data['draw'] * 2)

# Points par match
data['Pts/Match'] = data['Pts Classement (Est)'] / data['Matchs']

# 4. Affichage du classement par Points par Match
cols_resultat = ['Team', 'Matchs', 'win', 'Loss', 'draw', 'Win Rate (%)', 'Pts/Match']
print(data[cols_resultat].sort_values(by='Pts/Match', ascending=False))

#On va commencer Ã  mettre en place des data que l'on peut utiliser Partie Attaque

cols_totaux = ['P_att', 'P_def', 'essai_att', 'PenalitÃ©_att', 'Offloads',
               'metre_att', 'franchis_att', 'plaquage_att', 'Turnover_def',
               'plaquage_def', 'penalitÃ©_deff']

data_avg = data.copy()
for col in cols_totaux:
    data_avg[col + '_avg'] = data_avg[col] / data_avg['Matchs']

# 3. SÃ©lection des colonnes finales
cols_rates = ['Possesion', 'Occupation', 'Transf_att'] # Ceux qui sont dÃ©jÃ  en %
cols_finales = ['Team'] + [c + '_avg' for c in cols_totaux] + cols_rates

df_stats = data_avg[cols_finales]

# 4. Sauvegarde
df_stats.to_csv('Top14_Stats_Moyennes.csv', index=False)
print("Fichier 'Top14_Stats_Moyennes.csv' crÃ©Ã© !")

"""##PrÃ©diction de la 13 Ã¨me JournÃ©e de Top 14"""

import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

# ==========================================
# 1. CHARGEMENT ET NETTOYAGE DES STATS
# ==========================================
print("Step 1: Chargement des statistiques...")

# Chargement du fichier CSV
try:
    df_raw = pd.read_csv('Predictions top 14 - Feuille 1 (1).csv', header=1)
except FileNotFoundError:
    print("ERREUR : Le fichier 'Predictions top 14 - Feuille 1 (1).csv' est introuvable.")
    raise

# Fonction de nettoyage (Virgules et Espaces)
def nettoyer(val):
    if isinstance(val, str):
        return float(val.replace(' ', '').replace(',', '.'))
    return val

# Application du nettoyage
cols_a_nettoyer = ['Possesion', 'Occupation', 'Transf_att', 'metre_att', 'plaquage_def', 'P_att', 'P_def']
for col in df_raw.columns:
    if df_raw[col].dtype == 'object' and col != 'Team':
        try:
            df_raw[col] = df_raw[col].apply(nettoyer)
        except:
            pass

# Calcul des Moyennes par match
cols_totaux = ['P_att', 'P_def', 'essai_att', 'PenalitÃ©_att', 'Offloads',
               'metre_att', 'franchis_att', 'plaquage_att', 'Turnover_def',
               'plaquage_def', 'penalitÃ©_deff']

data_avg = df_raw.copy()
for col in cols_totaux:
    if col in data_avg.columns:
        data_avg[col + '_avg'] = data_avg[col] / data_avg['Matchs']

# SÃ©lection des colonnes finales pour le modÃ¨le
cols_rates = ['Possesion', 'Occupation', 'Transf_att']
cols_finales_stats = ['Team'] + [c + '_avg' for c in cols_totaux if c in data_avg.columns] + [c for c in cols_rates if c in data_avg.columns]
df_stats = data_avg[cols_finales_stats]

print(f"Stats chargÃ©es pour {len(df_stats)} Ã©quipes.")

# ==========================================
# 2. HISTORIQUE DES MATCHS (DATASET)
# ==========================================
history_matches = [
    {'Home': 'UBB', 'Visitor': 'RCT', 'Score_Home': 46, 'Score_Away': 7},
    {'Home': 'MHR', 'Visitor': 'UBB', 'Score_Home': 28, 'Score_Away': 24},
    {'Home': 'RCT', 'Visitor': 'USM', 'Score_Home': 54, 'Score_Away': 28},
    {'Home': 'ASM', 'Visitor': 'SFR', 'Score_Home': 36, 'Score_Away': 32},
    {'Home': 'ABO', 'Visitor': 'LOU', 'Score_Home': 22, 'Score_Away': 20},
    {'Home': 'COL', 'Visitor': 'USA', 'Score_Home': 23, 'Score_Away': 7},
    {'Home': 'STO', 'Visitor': 'RAC', 'Score_Home': 48, 'Score_Away': 24},
    {'Home': 'PAU', 'Visitor': 'ROC', 'Score_Home': 53, 'Score_Away': 33},
    {'Home': 'UBB', 'Visitor': 'PAU', 'Score_Home': 33, 'Score_Away': 34},
    {'Home': 'LOU', 'Visitor': 'ASM', 'Score_Home': 43, 'Score_Away': 24},
    {'Home': 'RAC', 'Visitor': 'ABO', 'Score_Home': 47, 'Score_Away': 27},
    {'Home': 'USM', 'Visitor': 'STO', 'Score_Home': 7, 'Score_Away': 49},
    {'Home': 'USA', 'Visitor': 'MHR', 'Score_Home': 0, 'Score_Away': 28},
    {'Home': 'ROC', 'Visitor': 'COL', 'Score_Home': 17, 'Score_Away': 19},
    {'Home': 'SFR', 'Visitor': 'RCT', 'Score_Home': 51, 'Score_Away': 24},
    {'Home': 'RCT', 'Visitor': 'LOU', 'Score_Home': 54, 'Score_Away': 21},
    {'Home': 'PAU', 'Visitor': 'USA', 'Score_Home': 27, 'Score_Away': 23},
    {'Home': 'ABO', 'Visitor': 'USM', 'Score_Home': 49, 'Score_Away': 7},
    {'Home': 'COL', 'Visitor': 'UBB', 'Score_Home': 26, 'Score_Away': 28},
    {'Home': 'MHR', 'Visitor': 'ASM', 'Score_Home': 7, 'Score_Away': 9},
    {'Home': 'STO', 'Visitor': 'SFR', 'Score_Home': 29, 'Score_Away': 17},
    {'Home': 'ROC', 'Visitor': 'RAC', 'Score_Home': 33, 'Score_Away': 6},
    {'Home': 'LOU', 'Visitor': 'ROC', 'Score_Home': 19, 'Score_Away': 36},
    {'Home': 'RAC', 'Visitor': 'PAU', 'Score_Home': 15, 'Score_Away': 10},
    {'Home': 'SFR', 'Visitor': 'MHR', 'Score_Home': 35, 'Score_Away': 12},
    {'Home': 'ASM', 'Visitor': 'COL', 'Score_Home': 63, 'Score_Away': 14},
    {'Home': 'USM', 'Visitor': 'USA', 'Score_Home': 29, 'Score_Away': 22},
    {'Home': 'UBB', 'Visitor': 'ABO', 'Score_Home': 41, 'Score_Away': 12},
    {'Home': 'STO', 'Visitor': 'RCT', 'Score_Home': 59, 'Score_Away': 24},
    {'Home': 'ABO', 'Visitor': 'ASM', 'Score_Home': 44, 'Score_Away': 17},
    {'Home': 'COL', 'Visitor': 'SFR', 'Score_Home': 29, 'Score_Away': 24},
    {'Home': 'MHR', 'Visitor': 'LOU', 'Score_Home': 35, 'Score_Away': 13},
    {'Home': 'ROC', 'Visitor': 'USM', 'Score_Home': 54, 'Score_Away': 19},
    {'Home': 'USA', 'Visitor': 'UBB', 'Score_Home': 12, 'Score_Away': 27},
    {'Home': 'PAU', 'Visitor': 'STO', 'Score_Home': 30, 'Score_Away': 26},
    {'Home': 'RCT', 'Visitor': 'RAC', 'Score_Home': 45, 'Score_Away': 21},
    {'Home': 'PAU', 'Visitor': 'ABO', 'Score_Home': 47, 'Score_Away': 24},
    {'Home': 'SFR', 'Visitor': 'ROC', 'Score_Home': 26, 'Score_Away': 24},
    {'Home': 'LOU', 'Visitor': 'USA', 'Score_Home': 44, 'Score_Away': 19},
    {'Home': 'RAC', 'Visitor': 'MHR', 'Score_Home': 32, 'Score_Away': 25},
    {'Home': 'USM', 'Visitor': 'COL', 'Score_Home': 28, 'Score_Away': 32},
    {'Home': 'ASM', 'Visitor': 'RCT', 'Score_Home': 27, 'Score_Away': 10},
    {'Home': 'STO', 'Visitor': 'UBB', 'Score_Home': 56, 'Score_Away': 13},
    {'Home': 'MHR', 'Visitor': 'ROC', 'Score_Home': 37, 'Score_Away': 13},
    {'Home': 'RCT', 'Visitor': 'PAU', 'Score_Home': 33, 'Score_Away': 17},
    {'Home': 'ASM', 'Visitor': 'USM', 'Score_Home': 84, 'Score_Away': 31},
    {'Home': 'COL', 'Visitor': 'RAC', 'Score_Home': 20, 'Score_Away': 16},
    {'Home': 'USA', 'Visitor': 'SFR', 'Score_Home': 11, 'Score_Away': 28},
    {'Home': 'UBB', 'Visitor': 'LOU', 'Score_Home': 32, 'Score_Away': 20},
    {'Home': 'ABO', 'Visitor': 'STO', 'Score_Home': 40, 'Score_Away': 26},
    {'Home': 'SFR', 'Visitor': 'UBB', 'Score_Home': 28, 'Score_Away': 7},
    {'Home': 'ROC', 'Visitor': 'USA', 'Score_Home': 31, 'Score_Away': 8},
    {'Home': 'RAC', 'Visitor': 'ASM', 'Score_Home': 43, 'Score_Away': 31},
    {'Home': 'PAU', 'Visitor': 'LOU', 'Score_Home': 40, 'Score_Away': 15},
    {'Home': 'USM', 'Visitor': 'MHR', 'Score_Home': 22, 'Score_Away': 22},
    {'Home': 'STO', 'Visitor': 'COL', 'Score_Home': 59, 'Score_Away': 12},
    {'Home': 'ABO', 'Visitor': 'RCT', 'Score_Home': 35, 'Score_Away': 32},
    {'Home': 'ASM', 'Visitor': 'PAU', 'Score_Home': 50, 'Score_Away': 27},
    {'Home': 'COL', 'Visitor': 'ABO', 'Score_Home': 48, 'Score_Away': 17},
    {'Home': 'LOU', 'Visitor': 'SFR', 'Score_Home': 42, 'Score_Away': 37},
    {'Home': 'USA', 'Visitor': 'RAC', 'Score_Home': 15, 'Score_Away': 28},
    {'Home': 'UBB', 'Visitor': 'USM', 'Score_Home': 71, 'Score_Away': 24},
    {'Home': 'MHR', 'Visitor': 'STO', 'Score_Home': 44, 'Score_Away': 14},
    {'Home': 'RCT', 'Visitor': 'ROC', 'Score_Home': 39, 'Score_Away': 14},
    {'Home': 'USM', 'Visitor': 'LOU', 'Score_Home': 18, 'Score_Away': 25},
    {'Home': 'ABO', 'Visitor': 'MHR', 'Score_Home': 26, 'Score_Away': 23},
    {'Home': 'PAU', 'Visitor': 'SFR', 'Score_Home': 34, 'Score_Away': 10},
    {'Home': 'ROC', 'Visitor': 'ASM', 'Score_Home': 34, 'Score_Away': 16},
    {'Home': 'STO', 'Visitor': 'USA', 'Score_Home': 31, 'Score_Away': 13},
    {'Home': 'RCT', 'Visitor': 'COL', 'Score_Home': 16, 'Score_Away': 12},
    {'Home': 'RAC', 'Visitor': 'UBB', 'Score_Home': 44, 'Score_Away': 32},
    {'Home': 'SFR', 'Visitor': 'USM', 'Score_Home': 47, 'Score_Away': 24},
    {'Home': 'USA', 'Visitor': 'ABO', 'Score_Home': 19, 'Score_Away': 26},
    {'Home': 'COL', 'Visitor': 'PAU', 'Score_Home': 15, 'Score_Away': 17},
    {'Home': 'LOU', 'Visitor': 'RAC', 'Score_Home': 32, 'Score_Away': 7},
    {'Home': 'MHR', 'Visitor': 'RCT', 'Score_Home': 17, 'Score_Away': 27},
    {'Home': 'UBB', 'Visitor': 'ROC', 'Score_Home': 23, 'Score_Away': 18},
    {'Home': 'ASM', 'Visitor': 'STO', 'Score_Home': 24, 'Score_Away': 34}
]

upcoming_matches = [
    {'Home': 'RAC', 'Visitor': 'USM'},
    {'Home': 'COL', 'Visitor': 'LOU'},
    {'Home': 'ABO', 'Visitor': 'SFR'},
    {'Home': 'ASM', 'Visitor': 'UBB'},
    {'Home': 'PAU', 'Visitor': 'MHR'},
    {'Home': 'RCT', 'Visitor': 'USA'},
    {'Home': 'STO', 'Visitor': 'ROC'},
]

# ==========================================
# 3. FONCTION DE PRÃ‰PARATION (FUSION)
# ==========================================
def prepare_data(matches_list, stats_df, is_training=True):
    df = pd.DataFrame(matches_list)

    # Merge Domicile
    df = df.merge(stats_df, left_on='Home', right_on='Team')
    rename_home = {col: col + '_Home' for col in stats_df.columns if col != 'Team'}
    df = df.rename(columns=rename_home)

    # Merge ExtÃ©rieur
    df = df.merge(stats_df, left_on='Visitor', right_on='Team')
    rename_visitor = {col: col + '_Visitor' for col in stats_df.columns if col != 'Team'}
    df = df.rename(columns=rename_visitor)

    # DiffÃ©rentiels
    feature_cols = []
    cols_stats = [c for c in stats_df.columns if c != 'Team']
    for col in cols_stats:
        diff_col = 'Diff_' + col
        df[diff_col] = df[col + '_Home'] - df[col + '_Visitor']
        feature_cols.append(diff_col)

    target = None
    if is_training:
        df['HomeWin'] = (df['Score_Home'] > df['Score_Away']).astype(float)
        target = df['HomeWin'].values

    return df, df[feature_cols].values, target, feature_cols

print("Step 2: PrÃ©paration des donnÃ©es...")
# PrÃ©paration TRAIN
df_train, X_train_raw, y_train, features = prepare_data(history_matches, df_stats, is_training=True)

# PrÃ©paration PREDICT
df_upcoming, X_upcoming_raw, _, _ = prepare_data(upcoming_matches, df_stats, is_training=False)

# Mise Ã  l'Ã©chelle (Scaler)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train_raw)
X_upcoming_scaled = scaler.transform(X_upcoming_raw)

# Tensors PyTorch
X_train_tensor = torch.FloatTensor(X_train_scaled)
y_train_tensor = torch.FloatTensor(y_train).view(-1, 1)
X_upcoming_tensor = torch.FloatTensor(X_upcoming_scaled)

# ==========================================
# 4. MODÃˆLE DEEP LEARNING (BATCHNORM + DROPOUT)
# ==========================================
class RugbyPredictor(nn.Module):
    def __init__(self, input_size):
        super(RugbyPredictor, self).__init__()
        self.fc1 = nn.Linear(input_size, 32)
        self.bn1 = nn.BatchNorm1d(32)
        self.fc2 = nn.Linear(32, 16)
        self.bn2 = nn.BatchNorm1d(16)
        self.fc3 = nn.Linear(16, 1)

        self.relu = nn.ReLU()
        self.dropout = nn.Dropout(p=0.3)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        out = self.dropout(self.relu(self.bn1(self.fc1(x))))
        out = self.dropout(self.relu(self.bn2(self.fc2(out))))
        out = self.sigmoid(self.fc3(out))
        return out

model = RugbyPredictor(input_size=X_train_tensor.shape[1])
criterion = nn.BCELoss()
optimizer = optim.Adam(model.parameters(), lr=0.005)

# ==========================================
# 5. ENTRAÃŽNEMENT
# ==========================================
print("Step 3: EntraÃ®nement du modÃ¨le...")
epochs = 30
for epoch in range(epochs):
    outputs = model(X_train_tensor)
    loss = criterion(outputs, y_train_tensor)

    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    if (epoch+1) % 100 == 0:
        print(f'Epoch [{epoch+1}/{epochs}], Loss: {loss.item():.4f}')

# ==========================================
# 6. RÃ‰SULTATS
# ==========================================
model.eval()
with torch.no_grad():
    predictions = model(X_upcoming_tensor)

df_upcoming['Prob_Victoire_Domicile'] = predictions.numpy()
df_upcoming['Vainqueur_Probable'] = df_upcoming.apply(
    lambda x: x['Home'] if x['Prob_Victoire_Domicile'] > 0.5 else x['Visitor'], axis=1
)
df_upcoming['Confiance'] = df_upcoming.apply(
    lambda x: x['Prob_Victoire_Domicile'] if x['Prob_Victoire_Domicile'] > 0.5 else 1 - x['Prob_Victoire_Domicile'], axis=1
)

print("\nðŸ”® --- PRÃ‰DICTIONS TOP 14 (Prochaine JournÃ©e) ---")
cols_res = ['Home', 'Visitor', 'Vainqueur_Probable', 'Confiance']
print(df_upcoming[cols_res].sort_values(by='Confiance', ascending=False).to_markdown(index=False, floatfmt=".1%"))

"""##PrÃ©diction du classement final du top 14

"""

# ==========================================
# 1. PARAMÃˆTRES ET POINTS ACTUELS
# ==========================================
# Points actuels au classement (avant la simulation)
current_points = {
    'PAU': 42, 'STO': 42, 'UBB': 34, 'RCT': 34,
    'SFR': 33, 'MHR': 32, 'ROC': 31, 'ABO': 30,
    'COL': 29, 'RAC': 28, 'ASM': 27, 'LOU': 23,
    'USM': 7, 'USA': 5
}

# Mapping des noms d'Ã©quipes
team_map = {
    "Bordeaux BÃ¨gles": "UBB", "Toulon": "RCT", "Montpellier": "MHR",
    "Montauban": "USM", "Clermont": "ASM", "Stade FranÃ§ais": "SFR",
    "Bayonne": "ABO", "Lyon": "LOU", "Castres": "COL",
    "Perpignan": "USA", "Toulouse": "STO", "Racing 92": "RAC",
    "Pau": "PAU", "La Rochelle": "ROC", "RCO": "ROC"
}

# ==========================================
# 2. CHARGEMENT ET CALCUL DES MOYENNES
# ==========================================
print("Step 1: Chargement et Calcul des Moyennes...")
try:
    df_raw = pd.read_csv('Predictions top 14moy - Feuille 1.csv', header=1)
except FileNotFoundError:
    print("ERREUR: Fichier introuvable.")
    raise

# Fonction de nettoyage (Texte -> Chiffre)
def nettoyer(val):
    if isinstance(val, str):
        val = val.replace(' ', '').replace(',', '.')
        # Parfois il reste des caractÃ¨res invisibles
        try:
            return float(val)
        except:
            return 0.0
    return float(val)

# 1. On nettoie tout le tableau d'abord
cols_to_clean = [
    'P_att_home', 'P_att_away', 'P_def_home', 'P_def_away',
    'Possesion', 'Occupation', 'Transf_att', 'metre_att',
    'plaquage_def', 'Offloads', 'essai_att', 'PenalitÃ©_att',
    'franchis_att', 'plaquage_att', 'Turnover_def', 'penalitÃ©_deff'
]

for col in cols_to_clean:
    if col in df_raw.columns:
        df_raw[col] = df_raw[col].apply(nettoyer)

# 2. CALCUL DES MOYENNES (C'est ce qui manquait !)
# On divise les totaux par le nombre de matchs jouÃ©s pour avoir une stat comparable
cols_totaux = ['essai_att', 'PenalitÃ©_att', 'Offloads', 'metre_att',
               'franchis_att', 'plaquage_att', 'Turnover_def',
               'plaquage_def', 'penalitÃ©_deff']

df_stats = df_raw.copy()
for col in cols_totaux:
    if col in df_stats.columns:
        # On crÃ©e une nouvelle colonne "_avg"
        df_stats[col + '_avg'] = df_stats[col] / df_stats['Matchs']

print("Stats avancÃ©es calculÃ©es (Offloads/match, MÃ¨tres/match, etc.)")

# ==========================================
# 3. HISTORIQUE & CALENDRIER
# ==========================================
# Historique des rÃ©sultats (Data d'entraÃ®nement)
history_matches = [
    {'Home': 'UBB', 'Visitor': 'RCT', 'Score_Home': 46, 'Score_Away': 7},
    {'Home': 'MHR', 'Visitor': 'UBB', 'Score_Home': 28, 'Score_Away': 24},
    {'Home': 'RCT', 'Visitor': 'USM', 'Score_Home': 54, 'Score_Away': 28},
    {'Home': 'ASM', 'Visitor': 'SFR', 'Score_Home': 36, 'Score_Away': 32},
    {'Home': 'ABO', 'Visitor': 'LOU', 'Score_Home': 22, 'Score_Away': 20},
    {'Home': 'COL', 'Visitor': 'USA', 'Score_Home': 23, 'Score_Away': 7},
    {'Home': 'STO', 'Visitor': 'RAC', 'Score_Home': 48, 'Score_Away': 24},
    {'Home': 'PAU', 'Visitor': 'ROC', 'Score_Home': 53, 'Score_Away': 33},
    {'Home': 'UBB', 'Visitor': 'PAU', 'Score_Home': 33, 'Score_Away': 34},
    {'Home': 'LOU', 'Visitor': 'ASM', 'Score_Home': 43, 'Score_Away': 24},
    {'Home': 'RAC', 'Visitor': 'ABO', 'Score_Home': 47, 'Score_Away': 27},
    {'Home': 'USM', 'Visitor': 'STO', 'Score_Home': 7, 'Score_Away': 49},
    {'Home': 'USA', 'Visitor': 'MHR', 'Score_Home': 0, 'Score_Away': 28},
    {'Home': 'ROC', 'Visitor': 'COL', 'Score_Home': 17, 'Score_Away': 19},
    {'Home': 'SFR', 'Visitor': 'RCT', 'Score_Home': 51, 'Score_Away': 24},
    {'Home': 'RCT', 'Visitor': 'LOU', 'Score_Home': 54, 'Score_Away': 21},
    {'Home': 'PAU', 'Visitor': 'USA', 'Score_Home': 27, 'Score_Away': 23},
    {'Home': 'ABO', 'Visitor': 'USM', 'Score_Home': 49, 'Score_Away': 7},
    {'Home': 'COL', 'Visitor': 'UBB', 'Score_Home': 26, 'Score_Away': 28},
    {'Home': 'MHR', 'Visitor': 'ASM', 'Score_Home': 7, 'Score_Away': 9},
    {'Home': 'STO', 'Visitor': 'SFR', 'Score_Home': 29, 'Score_Away': 17},
    {'Home': 'ROC', 'Visitor': 'RAC', 'Score_Home': 33, 'Score_Away': 6},
    {'Home': 'LOU', 'Visitor': 'ROC', 'Score_Home': 19, 'Score_Away': 36},
    {'Home': 'RAC', 'Visitor': 'PAU', 'Score_Home': 15, 'Score_Away': 10},
    {'Home': 'SFR', 'Visitor': 'MHR', 'Score_Home': 35, 'Score_Away': 12},
    {'Home': 'ASM', 'Visitor': 'COL', 'Score_Home': 63, 'Score_Away': 14},
    {'Home': 'USM', 'Visitor': 'USA', 'Score_Home': 29, 'Score_Away': 22},
    {'Home': 'UBB', 'Visitor': 'ABO', 'Score_Home': 41, 'Score_Away': 12},
    {'Home': 'STO', 'Visitor': 'RCT', 'Score_Home': 59, 'Score_Away': 24},
    {'Home': 'ABO', 'Visitor': 'ASM', 'Score_Home': 44, 'Score_Away': 17},
    {'Home': 'COL', 'Visitor': 'SFR', 'Score_Home': 29, 'Score_Away': 24},
    {'Home': 'MHR', 'Visitor': 'LOU', 'Score_Home': 35, 'Score_Away': 13},
    {'Home': 'ROC', 'Visitor': 'USM', 'Score_Home': 54, 'Score_Away': 19},
    {'Home': 'USA', 'Visitor': 'UBB', 'Score_Home': 12, 'Score_Away': 27},
    {'Home': 'PAU', 'Visitor': 'STO', 'Score_Home': 30, 'Score_Away': 26},
    {'Home': 'RCT', 'Visitor': 'RAC', 'Score_Home': 45, 'Score_Away': 21},
    {'Home': 'PAU', 'Visitor': 'ABO', 'Score_Home': 47, 'Score_Away': 24},
    {'Home': 'SFR', 'Visitor': 'ROC', 'Score_Home': 26, 'Score_Away': 24},
    {'Home': 'LOU', 'Visitor': 'USA', 'Score_Home': 44, 'Score_Away': 19},
    {'Home': 'RAC', 'Visitor': 'MHR', 'Score_Home': 32, 'Score_Away': 25},
    {'Home': 'USM', 'Visitor': 'COL', 'Score_Home': 28, 'Score_Away': 32},
    {'Home': 'ASM', 'Visitor': 'RCT', 'Score_Home': 27, 'Score_Away': 10},
    {'Home': 'STO', 'Visitor': 'UBB', 'Score_Home': 56, 'Score_Away': 13},
    {'Home': 'MHR', 'Visitor': 'ROC', 'Score_Home': 37, 'Score_Away': 13},
    {'Home': 'RCT', 'Visitor': 'PAU', 'Score_Home': 33, 'Score_Away': 17},
    {'Home': 'ASM', 'Visitor': 'USM', 'Score_Home': 84, 'Score_Away': 31},
    {'Home': 'COL', 'Visitor': 'RAC', 'Score_Home': 20, 'Score_Away': 16},
    {'Home': 'USA', 'Visitor': 'SFR', 'Score_Home': 11, 'Score_Away': 28},
    {'Home': 'UBB', 'Visitor': 'LOU', 'Score_Home': 32, 'Score_Away': 20},
    {'Home': 'ABO', 'Visitor': 'STO', 'Score_Home': 40, 'Score_Away': 26},
    {'Home': 'SFR', 'Visitor': 'UBB', 'Score_Home': 28, 'Score_Away': 7},
    {'Home': 'ROC', 'Visitor': 'USA', 'Score_Home': 31, 'Score_Away': 8},
    {'Home': 'RAC', 'Visitor': 'ASM', 'Score_Home': 43, 'Score_Away': 31},
    {'Home': 'PAU', 'Visitor': 'LOU', 'Score_Home': 40, 'Score_Away': 15},
    {'Home': 'USM', 'Visitor': 'MHR', 'Score_Home': 22, 'Score_Away': 22},
    {'Home': 'STO', 'Visitor': 'COL', 'Score_Home': 59, 'Score_Away': 12},
    {'Home': 'ABO', 'Visitor': 'RCT', 'Score_Home': 35, 'Score_Away': 32},
    {'Home': 'ASM', 'Visitor': 'PAU', 'Score_Home': 50, 'Score_Away': 27},
    {'Home': 'COL', 'Visitor': 'ABO', 'Score_Home': 48, 'Score_Away': 17},
    {'Home': 'LOU', 'Visitor': 'SFR', 'Score_Home': 42, 'Score_Away': 37},
    {'Home': 'USA', 'Visitor': 'RAC', 'Score_Home': 15, 'Score_Away': 28},
    {'Home': 'UBB', 'Visitor': 'USM', 'Score_Home': 71, 'Score_Away': 24},
    {'Home': 'MHR', 'Visitor': 'STO', 'Score_Home': 44, 'Score_Away': 14},
    {'Home': 'RCT', 'Visitor': 'ROC', 'Score_Home': 39, 'Score_Away': 14},
    {'Home': 'USM', 'Visitor': 'LOU', 'Score_Home': 18, 'Score_Away': 25},
    {'Home': 'ABO', 'Visitor': 'MHR', 'Score_Home': 26, 'Score_Away': 23},
    {'Home': 'PAU', 'Visitor': 'SFR', 'Score_Home': 34, 'Score_Away': 10},
    {'Home': 'ROC', 'Visitor': 'ASM', 'Score_Home': 34, 'Score_Away': 16},
    {'Home': 'STO', 'Visitor': 'USA', 'Score_Home': 31, 'Score_Away': 13},
    {'Home': 'RCT', 'Visitor': 'COL', 'Score_Home': 16, 'Score_Away': 12},
    {'Home': 'RAC', 'Visitor': 'UBB', 'Score_Home': 44, 'Score_Away': 32},
    {'Home': 'SFR', 'Visitor': 'USM', 'Score_Home': 47, 'Score_Away': 24},
    {'Home': 'USA', 'Visitor': 'ABO', 'Score_Home': 19, 'Score_Away': 26},
    {'Home': 'COL', 'Visitor': 'PAU', 'Score_Home': 15, 'Score_Away': 17},
    {'Home': 'LOU', 'Visitor': 'RAC', 'Score_Home': 32, 'Score_Away': 7},
    {'Home': 'MHR', 'Visitor': 'RCT', 'Score_Home': 17, 'Score_Away': 27},
    {'Home': 'UBB', 'Visitor': 'ROC', 'Score_Home': 23, 'Score_Away': 18},
    {'Home': 'ASM', 'Visitor': 'STO', 'Score_Home': 24, 'Score_Away': 34}
]

# Parsing de tes matchs futurs
matches_text = """
Perpignan;Toulouse|Montauban;Clermont|Lyon;Pau|Montpellier;Bayonne|Stade FranÃ§ais;Castres|Bordeaux BÃ¨gles;Racing 92|La Rochelle;Toulon
Clermont;La Rochelle|Bayonne;Castres|Racing 92;Lyon|Toulon;Montpellier|Toulouse;Pau|Bordeaux BÃ¨gles;Stade FranÃ§ais|Perpignan;Montauban
Castres;Clermont|Montpellier;Stade FranÃ§ais|Racing 92;Perpignan|Pau;Toulon|La Rochelle;Lyon|Toulouse;Bayonne|Montauban;Bordeaux BÃ¨gles
Bayonne;Racing 92|Lyon;Montauban|Toulon;Clermont|Stade FranÃ§ais;Toulouse|La Rochelle;Montpellier|Bordeaux BÃ¨gles;Castres|Perpignan;Pau
Clermont;Bayonne|Castres;La Rochelle|Lyon;Toulon|Montpellier;Racing 92|Pau;Bordeaux BÃ¨gles|Stade FranÃ§ais;Perpignan|Toulouse;Montauban
Clermont;Montpellier|Racing 92;Castres|Toulon;Stade FranÃ§ais|La Rochelle;Pau|Bordeaux BÃ¨gles;Toulouse|Montauban;Bayonne|Perpignan;Lyon
Bayonne;La Rochelle|Castres;Montauban|Lyon;Bordeaux BÃ¨gles|Pau;Racing 92|Stade FranÃ§ais;Clermont|Toulouse;Montpellier|Perpignan;Toulon
Clermont;Lyon|Bayonne;Pau|Castres;Toulouse|Montpellier;Perpignan|Racing 92;Stade FranÃ§ais|La Rochelle;Bordeaux BÃ¨gles|Montauban;Toulon
Lyon;Castres|Toulon;Bayonne|Stade FranÃ§ais;Pau|Toulouse;Clermont|Bordeaux BÃ¨gles;Montpellier|Montauban;Racing 92|Perpignan;La Rochelle
Clermont;Perpignan|Bayonne;Bordeaux BÃ¨gles|Montpellier;Montauban|Racing 92;La Rochelle|Toulon;Toulouse|Pau;Castres|Stade FranÃ§ais;Lyon
Castres;Montpellier|Lyon;Bayonne|Racing 92;Toulon|Pau;Clermont|La Rochelle;Toulouse|Bordeaux BÃ¨gles;Perpignan|Montauban;Stade FranÃ§ais
Clermont;Racing 92|Montpellier;Pau|Toulon;Bordeaux BÃ¨gles|Stade FranÃ§ais;Bayonne|Toulouse;Lyon|Montauban;La Rochelle|Perpignan;Castres
Bayonne;Perpignan|Castres;Toulon|Lyon;Montpellier|Racing 92;Toulouse|Pau;Montauban|La Rochelle;Stade FranÃ§ais|Bordeaux BÃ¨gles;Clermont
"""
future_matches = []
lines = matches_text.strip().split('\n')
for line in lines:
    day_matches = line.split('|')
    for m in day_matches:
        parts = m.split(';')
        if len(parts) == 2:
            h_name, v_name = parts[0].strip(), parts[1].strip()
            if h_name in team_map and v_name in team_map:
                future_matches.append({'Home': team_map[h_name], 'Visitor': team_map[v_name]})

# ==========================================
# 4. PRÃ‰PARATION DES DONNÃ‰ES (AVEC FEATURES AVANCÃ‰ES)
# ==========================================
def prepare_data(matches_list, stats_df, is_training=True):
    df = pd.DataFrame(matches_list)

    # Merges (Domicile & ExtÃ©rieur)
    df = df.merge(stats_df, left_on='Home', right_on='Team')
    df = df.rename(columns=lambda x: x+'_Home' if x not in ['Home','Visitor','Score_Home','Score_Away'] else x)
    df = df.merge(stats_df, left_on='Visitor', right_on='Team')
    df = df.rename(columns=lambda x: x+'_Visitor' if x not in ['Home','Visitor','Score_Home','Score_Away'] and '_Home' not in x else x)

    # --- CRÃ‰ATION DE FEATURES COMPLEXES ---
    # Ici, on utilise enfin toute la richesse du CSV

    # 1. Attaque/DÃ©fense (Points Ã  Domicile vs ExtÃ©rieur)
    df['Diff_Points_Context'] = df['P_att_home_Home'] - df['P_def_away_Visitor']
    df['Diff_Points_Inverse'] = df['P_def_home_Home'] - df['P_att_away_Visitor'] # Plus c'est haut, meilleure est la dÃ©fense dom

    # 2. Jeu courant (MÃ¨tres & Offloads)
    # Comparaison de l'attaque Dom vs le "niveau moyen" des Ã©quipes
    df['Diff_Metres'] = df['metre_att_avg_Home'] - df['metre_att_avg_Visitor']
    df['Diff_Offloads'] = df['Offloads_avg_Home'] - df['Offloads_avg_Visitor']

    # 3. RÃ©alisme & Discipline
    df['Diff_Essais_Marques'] = df['essai_att_avg_Home'] - df['essai_att_avg_Visitor']
    df['Diff_Penalites_Concedees'] = df['penalitÃ©_deff_avg_Home'] - df['penalitÃ©_deff_avg_Visitor'] # NÃ©gatif = Mieux (moins de fautes)

    # 4. ContrÃ´le
    df['Diff_Possession'] = df['Possesion_Home'] - df['Possesion_Visitor']

    # Liste finale des features
    feature_cols = [
        'Diff_Points_Context', 'Diff_Points_Inverse',
        'Diff_Metres', 'Diff_Offloads',
        'Diff_Essais_Marques', 'Diff_Penalites_Concedees',
        'Diff_Possession'
    ]

    target = None
    if is_training:
        df['Score_Diff'] = df['Score_Home'] - df['Score_Away']
        target = df['Score_Diff'].values

    return df, df[feature_cols].values, target

# PrÃ©paration
df_train, X_train, y_train = prepare_data(history_matches, df_stats, True)
df_future, X_future, _ = prepare_data(future_matches, df_stats, False)

# Scaler (Indispensable car "MÃ¨tres" = 400 alors que "Essais" = 3)
scaler = RobustScaler(quantile_range=(25.0, 75.0))
X_train_scaled = scaler.fit_transform(X_train)
X_future_scaled = scaler.transform(X_future)

X_train_tensor = torch.FloatTensor(X_train_scaled)
y_train_tensor = torch.FloatTensor(y_train).view(-1, 1)
X_future_tensor = torch.FloatTensor(X_future_scaled)

X_train_split, X_val_split, y_train_split, y_val_split = train_test_split(
    X_train_tensor.numpy(), y_train_tensor.numpy(), test_size=0.12, random_state=42
)

# On reconvertit en Tensors PyTorch
X_train_sub = torch.FloatTensor(X_train_split)
y_train_sub = torch.FloatTensor(y_train_split)
X_val_sub = torch.FloatTensor(X_val_split)
y_val_sub = torch.FloatTensor(y_val_split)
# ==========================================
# 5. LE MODÃˆLE (Plus gros pour gÃ©rer plus d'infos)
# ==========================================
class AdvancedPredictor(nn.Module):
    def __init__(self, input_size):
        super(AdvancedPredictor, self).__init__()
        # On augmente la taille car on a 7 features maintenant
        self.fc1 = nn.Linear(input_size, 64)
        self.bn1 = nn.BatchNorm1d(64)
        self.fc2 = nn.Linear(64, 32)
        self.bn2 = nn.BatchNorm1d(32)
        self.fc3 = nn.Linear(32, 16)
        self.fc4 = nn.Linear(16, 1) # Sortie : Ã‰cart de points

        self.relu = nn.ReLU()
        self.dropout = nn.Dropout(0.27) # Dropout fort pour Ã©viter le par coeur

    def forward(self, x):
        x = self.dropout(self.relu(self.bn1(self.fc1(x))))
        x = self.dropout(self.relu(self.bn2(self.fc2(x))))
        x = self.relu(self.fc3(x))
        x = self.fc4(x)
        return x

model = AdvancedPredictor(input_size=X_train_tensor.shape[1])
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.005, weight_decay=1e-4)

print("Step 2: EntraÃ®nement du modÃ¨le avancÃ©...")
epochs = 125
train_losses = []
val_losses = []
for epoch in range(epochs):
    out = model(X_train_tensor)
    loss = criterion(out, y_train_tensor)
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
    model.eval() # Mode examen (pas de dropout ici)
    with torch.no_grad():
        val_out = model(X_val_sub)
        val_loss = criterion(val_out, y_val_sub)

    train_losses.append(loss.item())
    val_losses.append(val_loss.item())

    if (epoch+1) % 10 == 0:
        print(f"Epoch {epoch+1}: Train Loss = {loss.item():.1f} | Val Loss = {val_loss.item():.1f}")




# ==========================================
# 6. SIMULATION ET CLASSEMENT
# ==========================================
model.eval()
with torch.no_grad():
    predictions = model(X_future_tensor).numpy()


df_future['Pred_Ecart'] = predictions
simulated_points = current_points.copy()


print("\n--- SIMULATION DE LA FIN DE SAISON ---")
for index, row in df_future.iterrows():
    ecart = row['Pred_Ecart']
    h, v = row['Home'], row['Visitor']

    # Logique Bonus (Seuil 3 essais ~ 21 pts)
    pts_dom, pts_ext = 0, 0
    if ecart > 0:
        pts_dom += 4
        if ecart >= 21: pts_dom += 1 # BO
        if ecart <= 5: pts_ext += 1  # BD
    else:
        pts_ext += 4
        if abs(ecart) >= 21: pts_ext += 1 # BO
        if abs(ecart) <= 5: pts_dom += 1  # BD

    simulated_points[h] += pts_dom
    simulated_points[v] += pts_ext

# Affichage Classement
print("\nðŸ† --- CLASSEMENT FINAL PROJETÃ‰ ---")
sorted_rank = sorted(simulated_points.items(), key=lambda x: x[1], reverse=True)
for i, (team, pts) in enumerate(sorted_rank, 1):
    qualif = ""
    if i <= 2: qualif = "âœ… Demies"
    elif i <= 6: qualif = "ðŸ›¡ï¸ Barrages"
    elif i == 13: qualif = "âš ï¸ Barrage Maintien"
    elif i == 14: qualif = "ðŸ”» RelÃ©gation"
    print(f"{i}. {team} : {pts} pts {qualif}")




print("\nðŸ‰ --- DÃ‰TAIL DES MATCHS Ã€ VENIR ---")
print(f"{'DOMICILE':<15} vs {'EXTÃ‰RIEUR':<15} | {'VAINQUEUR PRÃ‰VU':<15} | {'SCORE ESTIMÃ‰'}")
print("-" * 75)

for index, row in df_future.iterrows():
    h = row['Home']
    v = row['Visitor']
    ecart = row['Pred_Ecart'] # Positif = Dom gagne, NÃ©gatif = Ext gagne

    # Logique d'affichage
    if ecart > 0:
        vainqueur = h
        phrase_score = f"+{abs(ecart):.0f} pts"
        # On ajoute une petite Ã©toile si c'est une grosse victoire (Bonus Offensif probable)
        if ecart > 20: phrase_score += " (BO?)"
    else:
        vainqueur = v
        phrase_score = f"+{abs(ecart):.0f} pts"
        if abs(ecart) > 20: phrase_score += " (BO?)"

    # Affichage en colonnes propres
    print(f"{h:<15} vs {v:<15} | {vainqueur:<15} | {phrase_score}")